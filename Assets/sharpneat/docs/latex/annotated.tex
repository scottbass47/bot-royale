\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_abstract_generational_algorithm}{Sharp\+Neat.\+Evolution\+Algorithms.\+Abstract\+Generational\+Algorithm$<$ T\+Genome $>$}} \\*Abstract class providing some common/baseline data and methods for implementations of I\+Evolution\+Algorithm }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_abstract_generational_algorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_network_1_1_activation_function_info}{Sharp\+Neat.\+Network.\+Activation\+Function\+Info}} \\*Represents a single item in an \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function_library}{I\+Activation\+Function\+Library}}. The item represents an \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function}{I\+Activation\+Function}} and its ID and selection probability within the owning \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function_library}{I\+Activation\+Function\+Library}} }{\pageref{struct_sharp_neat_1_1_network_1_1_activation_function_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_acyclic_network_depth_analysis}{Sharp\+Neat.\+Network.\+Acyclic\+Network\+Depth\+Analysis}} \\*An algorithm for analysing acyclic networks and calculating the depth of each node in the network. Bias and input nodes are defined as being at depth 0, the depth of all other nodes is defined as the maximum number of hops from the depth 0 nodes, so where multiple paths exist to a node (potentially with different numbers of hops) we take the maximum number of hops as that node\textquotesingle{}s depth }{\pageref{class_sharp_neat_1_1_network_1_1_acyclic_network_depth_analysis}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_genomes_1_1_neat_1_1_added_neuron_gene_struct}{Sharp\+Neat.\+Genomes.\+Neat.\+Added\+Neuron\+Gene\+Struct}} \\*Represents an added neuron. When a neuron is added to a neural network in N\+E\+AT an existing connection between two neurons is discarded and replaced with the new neuron and two new connections, one connection between the source neuron and the new neuron and another from the new neuron to the target neuron. This struct represents those three I\+Ds }{\pageref{struct_sharp_neat_1_1_genomes_1_1_neat_1_1_added_neuron_gene_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_arc_sin_h}{Sharp\+Neat.\+Network.\+Arc\+SinH}} \\*Rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Re\+LU}}) }{\pageref{class_sharp_neat_1_1_network_1_1_arc_sin_h}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_arc_tan}{Sharp\+Neat.\+Network.\+Arc\+Tan}} }{\pageref{class_sharp_neat_1_1_network_1_1_arc_tan}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_core_1_1_aux_fitness_info}{Sharp\+Neat.\+Core.\+Aux\+Fitness\+Info}} \\*Auxiliary fitness info, i.\+e. for evaluation metrics other than the primary fitness metric but that nonetheless we are interested in observing }{\pageref{struct_sharp_neat_1_1_core_1_1_aux_fitness_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_bipolar_gaussian}{Sharp\+Neat.\+Network.\+Bipolar\+Gaussian}} \\*Bipolar \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} activation function. Output range is -\/1 to 1, that is, the tails of the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} distribution curve tend towards -\/1 as abs(x) -\/$>$ Infinity and the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} peak is at y = 1 }{\pageref{class_sharp_neat_1_1_network_1_1_bipolar_gaussian}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_bipolar_sigmoid}{Sharp\+Neat.\+Network.\+Bipolar\+Sigmoid}} \\*Bipolar sigmoid activation function. Output range is -\/1 to 1 instead of the more normal 0 to 1 }{\pageref{class_sharp_neat_1_1_network_1_1_bipolar_sigmoid}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_connection}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Connection}} \\*Represents a single connection between two neurons in a \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Cyclic\+Network}} }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_connection}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_network_1_1_connection_endpoints_struct}{Sharp\+Neat.\+Network.\+Connection\+Endpoints\+Struct}} \\*Represents a connection between two nodes. Used primarily as a key into a Dictionary that uniquely identifies connections by their end points }{\pageref{struct_sharp_neat_1_1_network_1_1_connection_endpoints_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Gene}} \\*A gene that represents a single connection between neurons in N\+E\+AT }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_comparer}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Gene\+Comparer}} \\*Compares the innovation ID of Connection\+Genes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_comparer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_list}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Gene\+List}} \\*Represents a sorted list of \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene}{Connection\+Gene}} objects. The sorting of the items is done on request rather than being strictly enforced at all times (e.\+g. as part of adding and removing genes). This approach is currently more convenient for use in some of the routines that work with N\+E\+AT genomes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_list_builder}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Gene\+List\+Builder}} \\*Used for building a list of connection genes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_gene_list_builder}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_connection_list}{Sharp\+Neat.\+Network.\+Connection\+List}} \\*A concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_connection_list}{I\+Connection\+List}}. Part of the \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} type hierarchy }{\pageref{class_sharp_neat_1_1_network_1_1_connection_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Mutation\+Info}} \\*Each instance of \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info}{Connection\+Mutation\+Info}} describes a type of mutation and associated parameters }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info_list}{Sharp\+Neat.\+Genomes.\+Neat.\+Connection\+Mutation\+Info\+List}} \\*Represents a list of \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info}{Connection\+Mutation\+Info}} objects }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_connection_mutation_info_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_coordinate_vector}{Sharp\+Neat.\+Core.\+Coordinate\+Vector}} \\*General purpose representation of a point in a multidimensional space. A vector of coordinates, each coordinate defining the position within a dimension/axis defined by an ID }{\pageref{class_sharp_neat_1_1_core_1_1_coordinate_vector}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_item}{Sharp\+Neat.\+Genomes.\+Neat.\+Correlation\+Item}} \\*A single comparison item resulting from the comparison of two genomes. If the Correlation\+Item\+Type is Match then both connection gene properties will be non-\/null, otherwise one of them will be null and the other will hold a reference to a disjoint or excess connection gene }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_item}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_results}{Sharp\+Neat.\+Genomes.\+Neat.\+Correlation\+Results}} \\*The results from comparing two N\+E\+AT genomes and correlating their connection genes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_results}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_statistics}{Sharp\+Neat.\+Genomes.\+Neat.\+Correlation\+Statistics}} \\*Statistics resulting from the comparison of two N\+E\+AT genomes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_correlation_statistics}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_hyper_neat_1_1_cppn_genome_factory}{Sharp\+Neat.\+Genomes.\+Hyper\+Neat.\+Cppn\+Genome\+Factory}} \\*A sub-\/class of Neat\+Genome\+Factory for creating C\+P\+PN genomes }{\pageref{class_sharp_neat_1_1_genomes_1_1_hyper_neat_1_1_cppn_genome_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Cyclic\+Network}} \\*This class is provided for debugging and educational purposes. \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}{Fast\+Cyclic\+Network}} is functionally equivalent and is much faster and therefore should be used instead of \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Cyclic\+Network}} in most circumstances }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_cyclic_network_depth_analysis}{Sharp\+Neat.\+Network.\+Cyclic\+Network\+Depth\+Analysis}} \\*An algorithm for analysing cyclic networks and calculating the depth of each node in the network. Bias and input nodes are defined as being at depth 0, the depth of all other nodes is defined as the maximum number of hops from the depth 0 nodes, so where multiple paths exist to a node (potentially with different numbers of hops) we take the maximum number of hops as that node\textquotesingle{}s depth }{\pageref{class_sharp_neat_1_1_network_1_1_cyclic_network_depth_analysis}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_cyclic_network_factory}{Sharp\+Neat.\+Decoders.\+Cyclic\+Network\+Factory}} \\*Static factory for creating Cyclic\+Network\textquotesingle{}s from I\+Network\+Definition\textquotesingle{}s }{\pageref{class_sharp_neat_1_1_decoders_1_1_cyclic_network_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_cyclic_network_test}{Sharp\+Neat.\+Network.\+Cyclic\+Network\+Test}} \\*An algorithm for testing for the presence of at least one connectivity cycle within a network }{\pageref{class_sharp_neat_1_1_network_1_1_cyclic_network_test}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_default_activation_function_library}{Sharp\+Neat.\+Network.\+Default\+Activation\+Function\+Library}} \\*Default implementation of an \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function_library}{I\+Activation\+Function\+Library}}. Also provides static factory methods to create libraries with commonly used activation functions }{\pageref{class_sharp_neat_1_1_network_1_1_default_activation_function_library}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_default_complexity_regulation_strategy}{Sharp\+Neat.\+Evolution\+Algorithms.\+Complexity\+Regulation.\+Default\+Complexity\+Regulation\+Strategy}} \\*Default complexity regulation strategy. This strategy provides a choice of hard/absolute complexity ceiling or a ceiling relative to the complexity at the end of the most recent simplification phase. The strategy transitions from complexifying to simplifying when the ceiling is reached. Transitioning from simplifying to complexifying occurs when complexity is no longer falling {\itshape and} complexity is below the ceiling. This is determined by tracking a complexity moving average calculated over the past N generations }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_default_complexity_regulation_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_default_node_set_mapping_function}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Default\+Node\+Set\+Mapping\+Function}} \\*Defines a mapping between two node sets based on mapping all source nodes to all target nodes, but with an option to omit mappings where the distance between source and target node is over some threshold }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_default_node_set_mapping_function}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_distance_metrics_1_1_distance_metric_utils}{Sharp\+Neat.\+Distance\+Metrics.\+Distance\+Metric\+Utils}} \\*Static helper methods for distance metrics }{\pageref{class_sharp_neat_1_1_distance_metrics_1_1_distance_metric_utils}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_distance_metrics_1_1_euclidean_distance_metric}{Sharp\+Neat.\+Distance\+Metrics.\+Euclidean\+Distance\+Metric}} \\*Euclidean distance metric }{\pageref{class_sharp_neat_1_1_distance_metrics_1_1_euclidean_distance_metric}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_evaluation_info}{Sharp\+Neat.\+Core.\+Evaluation\+Info}} \\*Encapsulates genome evaluation data; specifically whether the genome has been evaluated, the genome\textquotesingle{}s fitness, how many times the genome has been evaluated and if more than once then the mean fitness }{\pageref{class_sharp_neat_1_1_core_1_1_evaluation_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_acyclic_network}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Fast\+Acyclic\+Network}} \\*A neural network implementation for acyclic networks }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_acyclic_network}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_fast_acyclic_network_factory}{Sharp\+Neat.\+Decoders.\+Fast\+Acyclic\+Network\+Factory}} \\*Static factory for creating Acyclic\+Network(s) from I\+Network\+Definition(s) }{\pageref{class_sharp_neat_1_1_decoders_1_1_fast_acyclic_network_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_connection}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Fast\+Connection}} \\*Working data struct for use in \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}{Fast\+Cyclic\+Network}} and sub-\/classes. Represents a single connection -\/ its weight and source/target neurons }{\pageref{struct_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_connection}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Fast\+Cyclic\+Network}} \\*A neural network class that represents a network with recurrent (cyclic) connections }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_fast_cyclic_network_factory}{Sharp\+Neat.\+Decoders.\+Fast\+Cyclic\+Network\+Factory}} \\*Static factory for creating Cyclic\+Network\textquotesingle{}s from I\+Network\+Definition\textquotesingle{}s }{\pageref{class_sharp_neat_1_1_decoders_1_1_fast_cyclic_network_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_relaxing_cyclic_network}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Fast\+Relaxing\+Cyclic\+Network}} \\*A version of \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}{Fast\+Cyclic\+Network}} that activates a network until it becomes \textquotesingle{}relaxed\textquotesingle{} rather than for some fixed number of iterations. This class is exactly the same as \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_cyclic_network}{Fast\+Cyclic\+Network}} in all other respects; See that class for more detailed info }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_fast_relaxing_cyclic_network}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_core_1_1_fitness_info}{Sharp\+Neat.\+Core.\+Fitness\+Info}} \\*Wrapper struct for fitness values }{\pageref{struct_sharp_neat_1_1_core_1_1_fitness_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Sharp\+Neat.\+Network.\+Gaussian}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} activation function. Output range is 0 to 1, that is, the tails of the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} distribution curve tend towards 0 as abs(x) -\/$>$ Infinity and the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} peak is at x = 0 }{\pageref{class_sharp_neat_1_1_network_1_1_gaussian}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_genome_fitness_comparer}{Sharp\+Neat.\+Core.\+Genome\+Fitness\+Comparer$<$ T\+Genome $>$}} \\*Sort genomes, highest fitness first. \mbox{\hyperlink{namespace_sharp_neat_1_1_genomes}{Genomes}} with equal fitness are secondary sorted by age (youngest first). Used by the selection routines to select the fittest and youngest genomes }{\pageref{class_sharp_neat_1_1_core_1_1_genome_fitness_comparer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_hyper_neat_decoder}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Hyper\+Neat\+Decoder}} \\*Decodes C\+P\+PN Neat\+Genome\textquotesingle{}s into concrete network instances. This decoder uses a Hyper\+N\+E\+AT substrate and queries a C\+P\+PN N\+E\+AT network to generate/grow a network from the substrate }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_hyper_neat_decoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function}{Sharp\+Neat.\+Network.\+I\+Activation\+Function}} \\*Interface for neural network activation functions. An activation function simply takes a single input value and produces a single output value. \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function}{I\+Activation\+Function}} allows for activation functions to be plugged in to neural network implementations. Typical activation functions would be a sigmoid or step function }{\pageref{interface_sharp_neat_1_1_network_1_1_i_activation_function}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_activation_function_library}{Sharp\+Neat.\+Network.\+I\+Activation\+Function\+Library}} \\*Represents a library of activation functions. Primarily for use in Hyper\+N\+E\+AT }{\pageref{interface_sharp_neat_1_1_network_1_1_i_activation_function_library}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_phenomes_1_1_i_black_box}{Sharp\+Neat.\+Phenomes.\+I\+Black\+Box}} \\*\mbox{\hyperlink{interface_sharp_neat_1_1_phenomes_1_1_i_black_box}{I\+Black\+Box}} represents an abstract device, system or function which has inputs and outputs. The internal workings and state of the box are not relevant to any method or class that accepts an \mbox{\hyperlink{interface_sharp_neat_1_1_phenomes_1_1_i_black_box}{I\+Black\+Box}} -\/ only that it has inputs and outputs and a means of activation. In N\+E\+AT the neural network implementations generally fit this pattern, that is\+: }{\pageref{interface_sharp_neat_1_1_phenomes_1_1_i_black_box}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_i_complexity_regulation_strategy}{Sharp\+Neat.\+Evolution\+Algorithms.\+Complexity\+Regulation.\+I\+Complexity\+Regulation\+Strategy}} \\*Represents a complexity regulation strategy }{\pageref{interface_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_i_complexity_regulation_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_connection_list}{Sharp\+Neat.\+Network.\+I\+Connection\+List}} \\*Represents a list of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_connection}{I\+Network\+Connection}}\textquotesingle{}s. Part of the \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} type hierarchy }{\pageref{interface_sharp_neat_1_1_network_1_1_i_connection_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_distance_metric}{Sharp\+Neat.\+Core.\+I\+Distance\+Metric}} \\*Represents a metric for measuring the distance between two genome positions in an encoding space, and thus the compatibility of the two genomes with respect to the probability of creating fit offspring }{\pageref{interface_sharp_neat_1_1_core_1_1_i_distance_metric}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_evolution_algorithm}{Sharp\+Neat.\+Core.\+I\+Evolution\+Algorithm$<$ T\+Genome $>$}} \\*A generic interface for evolution algorithm classes }{\pageref{interface_sharp_neat_1_1_core_1_1_i_evolution_algorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome}{Sharp\+Neat.\+Core.\+I\+Genome$<$ T\+Genome $>$}} \\*Generic interface for genome classes }{\pageref{interface_sharp_neat_1_1_core_1_1_i_genome}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_decoder}{Sharp\+Neat.\+Core.\+I\+Genome\+Decoder$<$ T\+Genome, T\+Phenome $>$}} \\*Generic interface for classes that decode genomes into phenomes }{\pageref{interface_sharp_neat_1_1_core_1_1_i_genome_decoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_factory}{Sharp\+Neat.\+Core.\+I\+Genome\+Factory$<$ T\+Genome $>$}} \\*Generic interface genome factory classes. Genome factories are intended to be used for creating initial populations, either random populations or from one or more seed genomes. However, genome reproduction is performed via the overloaded \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_aaa6484beaf3243a4759c72565dc3f8f0}{I\+Genome.\+Create\+Offspring()}} methods, placing these methods on \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome}{I\+Genome}} gives reproduction methods direct and convenient access to internal genome data }{\pageref{interface_sharp_neat_1_1_core_1_1_i_genome_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}{Sharp\+Neat.\+Core.\+I\+Genome\+List\+Evaluator$<$ T\+Genome $>$}} \\*Generic interface for evaluating a list of genomes. By operating on a list we allow concrete implementations of this interface to choose between evaluating each genome independently of the others, perhaps across several execution threads, or in some collective evaluation scheme such as an artificial life/world scenario }{\pageref{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_connection}{Sharp\+Neat.\+Network.\+I\+Network\+Connection}} \\*Represents a single network connection. Part of the \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} type hierarchy }{\pageref{interface_sharp_neat_1_1_network_1_1_i_network_connection}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{Sharp\+Neat.\+Network.\+I\+Network\+Definition}} \\*Abstracted representation of a network definition. This interface and the related types \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_node_list}{I\+Node\+List}}, \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_connection_list}{I\+Connection\+List}}, \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_node}{I\+Network\+Node}}, \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_connection}{I\+Network\+Connection}}, etc, allow networks to be described abstractly }{\pageref{interface_sharp_neat_1_1_network_1_1_i_network_definition}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_node}{Sharp\+Neat.\+Network.\+I\+Network\+Node}} \\*Represents a single network node. Part of the \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} type hierarchy }{\pageref{interface_sharp_neat_1_1_network_1_1_i_network_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_node_list}{Sharp\+Neat.\+Network.\+I\+Node\+List}} \\*Represents a list of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_node}{I\+Network\+Node}}\textquotesingle{}s. Part of the \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} type hierarchy }{\pageref{interface_sharp_neat_1_1_network_1_1_i_node_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_i_node_set_mapping_function}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+I\+Node\+Set\+Mapping\+Function}} \\*Implementations of \mbox{\hyperlink{interface_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_i_node_set_mapping_function}{I\+Node\+Set\+Mapping\+Function}} define a mapping between source and target node sets. Each mapping is interpreted/used as a connection between the source and target node. E.\+g. the simplest such function is to map every source node to every target node (N$\ast$M connections) }{\pageref{interface_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_i_node_set_mapping_function}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_phenome_evaluator}{Sharp\+Neat.\+Core.\+I\+Phenome\+Evaluator$<$ T\+Phenome $>$}} \\*Generic interface for phenome evaluation classes. Evaluates and assigns a fitness to individual T\+Phenome\textquotesingle{}s }{\pageref{interface_sharp_neat_1_1_core_1_1_i_phenome_evaluator}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_phenomes_1_1_i_signal_array}{Sharp\+Neat.\+Phenomes.\+I\+Signal\+Array}} \\*An abstraction of the \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Signal\+Array}} class. Provided to allow custom implementations of a signal array if required }{\pageref{interface_sharp_neat_1_1_phenomes_1_1_i_signal_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_speciation_strategy}{Sharp\+Neat.\+Core.\+I\+Speciation\+Strategy$<$ T\+Genome $>$}} \\*Represents a strategy for dividing genomes into distinct species }{\pageref{interface_sharp_neat_1_1_core_1_1_i_speciation_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_speciation_strategies_1_1_k_means_clustering_strategy}{Sharp\+Neat.\+Speciation\+Strategies.\+K\+Means\+Clustering\+Strategy$<$ T\+Genome $>$}} \\*An I\+Speciation\+Strategy that speciates genomes using the k-\/means clustering method. k-\/means requires a distance metric and as such this class requires am I\+Distance\+Metric to be provided at construction time. Different distance metrics can be used including Neat\+Distance\+Metric which is equivalent to the metric used in the standard N\+E\+AT method albeit with a different clustering/speciation algorithm (Standard N\+E\+AT does not use k-\/means) }{\pageref{class_sharp_neat_1_1_speciation_strategies_1_1_k_means_clustering_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_layer_info}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Layer\+Info}} \\*Stores a node and connection index that represent a layer within the network (the nodes and connections at a given depth in a network) }{\pageref{struct_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_layer_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_leaky_re_l_u}{Sharp\+Neat.\+Network.\+Leaky\+Re\+LU}} \\*Leaky rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Re\+LU}}) }{\pageref{class_sharp_neat_1_1_network_1_1_leaky_re_l_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_leaky_re_l_u_shifted}{Sharp\+Neat.\+Network.\+Leaky\+Re\+L\+U\+Shifted}} \\*Leaky rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Re\+LU}}). Shifted on the x-\/axis so that x=0 gives y=0.\+5, in keeping with the logistic sigmoid }{\pageref{class_sharp_neat_1_1_network_1_1_leaky_re_l_u_shifted}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_linear}{Sharp\+Neat.\+Network.\+Linear}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_linear}{Linear}} activation function with clipping. By \textquotesingle{}clipping\textquotesingle{} we mean the output value is linear between x = -\/1 and x = 1. Below -\/1 and above +1 the output is clipped at -\/1 and +1 respectively }{\pageref{class_sharp_neat_1_1_network_1_1_linear}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_logistic_function}{Sharp\+Neat.\+Network.\+Logistic\+Function}} \\*The logistic function }{\pageref{class_sharp_neat_1_1_network_1_1_logistic_function}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_logistic_function_steep}{Sharp\+Neat.\+Network.\+Logistic\+Function\+Steep}} \\*The logistic function with a steepened slope }{\pageref{class_sharp_neat_1_1_network_1_1_logistic_function_steep}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_distance_metrics_1_1_manhattan_distance_metric}{Sharp\+Neat.\+Distance\+Metrics.\+Manhattan\+Distance\+Metric}} \\*Manhattan distance metric }{\pageref{class_sharp_neat_1_1_distance_metrics_1_1_manhattan_distance_metric}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_mapping_signal_array}{Sharp\+Neat.\+Phenomes.\+Mapping\+Signal\+Array}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_mapping_signal_array}{Mapping\+Signal\+Array}} wraps a native array along with an indirection/mapping array. See \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Signal\+Array}} for more info }{\pageref{class_sharp_neat_1_1_phenomes_1_1_mapping_signal_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_max_minus_one}{Sharp\+Neat.\+Network.\+Max\+Minus\+One}} \\*y = max(-\/1, x). i.\+e. a rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Re\+LU}}) variant }{\pageref{class_sharp_neat_1_1_network_1_1_max_minus_one}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_algorithm_stats}{Sharp\+Neat.\+Evolution\+Algorithms.\+Neat\+Algorithm\+Stats}} \\*Neat evolution algorithm statistics }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_algorithm_stats}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_evolution_algorithm}{Sharp\+Neat.\+Evolution\+Algorithms.\+Neat\+Evolution\+Algorithm$<$ T\+Genome $>$}} \\*Implementation of the N\+E\+AT evolution algorithm. Incorporates\+: }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_evolution_algorithm}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_evolution_algorithm_parameters}{Sharp\+Neat.\+Evolution\+Algorithms.\+Neat\+Evolution\+Algorithm\+Parameters}} \\*Parameters specific to the N\+E\+AT evolution algorithm }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_neat_evolution_algorithm_parameters}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome}{Sharp\+Neat.\+Genomes.\+Neat.\+Neat\+Genome}} \\*A genome class for Neuro Evolution of Augmenting Topologies (N\+E\+AT) }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_neat_1_1_neat_genome_decoder}{Sharp\+Neat.\+Decoders.\+Neat.\+Neat\+Genome\+Decoder}} \\*Decodes Neat\+Genome\textquotesingle{}s into concrete network instances }{\pageref{class_sharp_neat_1_1_decoders_1_1_neat_1_1_neat_genome_decoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_factory}{Sharp\+Neat.\+Genomes.\+Neat.\+Neat\+Genome\+Factory}} \\*An I\+Genome\+Factory for Neat\+Genomes. We use the factory as a means of generating an initial population either randomly or using a seed genome or genomes. Subsequently all \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome}{Neat\+Genome}} objects keep a reference to this factory object for convenient access to \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome}{Neat\+Genome}} parameters and ID generator objects }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_parameters}{Sharp\+Neat.\+Genomes.\+Neat.\+Neat\+Genome\+Parameters}} \\*Represents parameters specific to N\+E\+AT genomes. E.\+g. parameters that describe probabilities for the different types of mutation and the proportion of possible connections to instantiate between input and output neurons within the initial population }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_parameters}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_stats}{Sharp\+Neat.\+Genomes.\+Neat.\+Neat\+Genome\+Stats}} \\*Various statistics for \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome}{Neat\+Genome}} }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neat_genome_stats}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_network_activation_scheme}{Sharp\+Neat.\+Decoders.\+Network\+Activation\+Scheme}} \\*Represents network activation schemes. E.\+g. fixed number of activation timesteps or activation until the network becomes \textquotesingle{}relaxed\textquotesingle{}. Relaxed here means that no node\textquotesingle{}s output value changed by more than some threshold value }{\pageref{class_sharp_neat_1_1_decoders_1_1_network_activation_scheme}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_network_connection}{Sharp\+Neat.\+Network.\+Network\+Connection}} \\*Concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_connection}{I\+Network\+Connection}} }{\pageref{class_sharp_neat_1_1_network_1_1_network_connection}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_network_connectivity_data}{Sharp\+Neat.\+Network.\+Network\+Connectivity\+Data}} \\*\mbox{\hyperlink{namespace_sharp_neat_1_1_network}{Network}} connectivity data for a network. Connectivity data in a form that is convenient for network traversal algorithms }{\pageref{class_sharp_neat_1_1_network_1_1_network_connectivity_data}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_network_definition}{Sharp\+Neat.\+Network.\+Network\+Definition}} \\*Concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}}. This class represents network definitions independently of any other requirements, e.\+g. a Neat\+Genome is also an \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_definition}{I\+Network\+Definition}} but with additional baggage. This class is useful for representing network definitions, e.\+g. when creating a network instance from a Hyper\+N\+E\+AT substrate }{\pageref{class_sharp_neat_1_1_network_1_1_network_definition}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_network_1_1_network_depth_info}{Sharp\+Neat.\+Network.\+Network\+Depth\+Info}} \\*Conveys summary information from a network depth analysis }{\pageref{struct_sharp_neat_1_1_network_1_1_network_depth_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_network_node}{Sharp\+Neat.\+Network.\+Network\+Node}} \\*Concrete implementation of an \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_network_node}{I\+Network\+Node}} }{\pageref{class_sharp_neat_1_1_network_1_1_network_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_neuron}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Neuron}} \\*Represents a single neuron in a \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Cyclic\+Network}} }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_neuron}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neuron_gene}{Sharp\+Neat.\+Genomes.\+Neat.\+Neuron\+Gene}} \\*A gene that represents a single neuron in N\+E\+AT }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neuron_gene}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neuron_gene_list}{Sharp\+Neat.\+Genomes.\+Neat.\+Neuron\+Gene\+List}} \\*Represents a sorted list of \mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neuron_gene}{Neuron\+Gene}} objects. The sorting of the items is done on request rather than being strictly enforced at all times (e.\+g. as part of adding and removing items). This approach is currently more convenient for use in some of the routines that work with N\+E\+AT genomes }{\pageref{class_sharp_neat_1_1_genomes_1_1_neat_1_1_neuron_gene_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_node_connectivity_data}{Sharp\+Neat.\+Network.\+Node\+Connectivity\+Data}} \\*Stored the I\+Ds of nodes that connect in and out of a given node }{\pageref{class_sharp_neat_1_1_network_1_1_node_connectivity_data}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_node_list}{Sharp\+Neat.\+Network.\+Node\+List}} \\*Concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_network_1_1_i_node_list}{I\+Node\+List}} }{\pageref{class_sharp_neat_1_1_network_1_1_node_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_node_set_mapping}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Node\+Set\+Mapping}} \\*Describes a mapping between nodesets. Packages an \mbox{\hyperlink{interface_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_i_node_set_mapping_function}{I\+Node\+Set\+Mapping\+Function}} with indexes into a list of node sets that identify the source and target nodesets for the mapping }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_node_set_mapping}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_null_complexity_regulation_strategy}{Sharp\+Neat.\+Evolution\+Algorithms.\+Complexity\+Regulation.\+Null\+Complexity\+Regulation\+Strategy}} \\*Null strategy. Fixed to Complexifying mode }{\pageref{class_sharp_neat_1_1_evolution_algorithms_1_1_complexity_regulation_1_1_null_complexity_regulation_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_null_fn}{Sharp\+Neat.\+Network.\+Null\+Fn}} \\*Null activation function. Returns zero regardless of input }{\pageref{class_sharp_neat_1_1_network_1_1_null_fn}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_output_mapping_signal_array}{Sharp\+Neat.\+Phenomes.\+Output\+Mapping\+Signal\+Array}} \\*A \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_mapping_signal_array}{Mapping\+Signal\+Array}} that applies the bounds interval \mbox{[}0,1\mbox{]} to returned values }{\pageref{class_sharp_neat_1_1_phenomes_1_1_output_mapping_signal_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_output_signal_array}{Sharp\+Neat.\+Phenomes.\+Output\+Signal\+Array}} \\*A \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Signal\+Array}} that applies the bounds interval \mbox{[}0,1\mbox{]} to returned values }{\pageref{class_sharp_neat_1_1_phenomes_1_1_output_signal_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_parallel_genome_list_evaluator}{Sharp\+Neat.\+Core.\+Parallel\+Genome\+List\+Evaluator$<$ T\+Genome, T\+Phenome $>$}} \\*A concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}{I\+Genome\+List\+Evaluator}} that evaluates genomes independently of each other and in parallel (on multiple execution threads) }{\pageref{class_sharp_neat_1_1_core_1_1_parallel_genome_list_evaluator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_speciation_strategies_1_1_parallel_k_means_clustering_strategy}{Sharp\+Neat.\+Speciation\+Strategies.\+Parallel\+K\+Means\+Clustering\+Strategy$<$ T\+Genome $>$}} \\*An I\+Speciation\+Strategy that speciates genomes using the k-\/means clustering method. k-\/means requires a distance metric and as such this class requires am I\+Distance\+Metric to be provided at construction time. Different distance metrics can be used including Neat\+Distance\+Metric which is equivalent to the metric used in the standard N\+E\+AT method albeit with a different clustering/speciation algorithm (Standard N\+E\+AT does not use k-\/means) }{\pageref{class_sharp_neat_1_1_speciation_strategies_1_1_parallel_k_means_clustering_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_utility_1_1_point2_d_double}{Sharp\+Neat.\+Utility.\+Point2\+D\+Double}} }{\pageref{struct_sharp_neat_1_1_utility_1_1_point2_d_double}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_polynomial_approximant_steep}{Sharp\+Neat.\+Network.\+Polynomial\+Approximant\+Steep}} \\*A very close approximation of the logistic function that avoids use of exp() and is therefore typically much faster to compute, while giving an almost identical sigmoid curve }{\pageref{class_sharp_neat_1_1_network_1_1_polynomial_approximant_steep}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_quadratic_sigmoid}{Sharp\+Neat.\+Network.\+Quadratic\+Sigmoid}} \\*A sigmoid formed by two sub-\/sections of the y=x$^\wedge$2 curve }{\pageref{class_sharp_neat_1_1_network_1_1_quadratic_sigmoid}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_speciation_strategies_1_1_random_clustering_strategy}{Sharp\+Neat.\+Speciation\+Strategies.\+Random\+Clustering\+Strategy$<$ T\+Genome $>$}} \\*A speciation strategy that allocates genomes to species randomly. Although allocation is random the strategy does maintain evenly sized species. Primarily used for testing/debugging and demonstrating comparative effectiveness of random allocation compared to other strategies }{\pageref{class_sharp_neat_1_1_speciation_strategies_1_1_random_clustering_strategy}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_rbf_gaussian}{Sharp\+Neat.\+Network.\+Rbf\+Gaussian}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} activation function. Output range is 0 to 1, that is, the tails of the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} distribution curve tend towards 0 as abs(x) -\/$>$ Infinity and the \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_gaussian}{Gaussian}} peak is at x = 0 }{\pageref{class_sharp_neat_1_1_network_1_1_rbf_gaussian}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_genomes_1_1_rbf_neat_1_1_rbf_genome_factory}{Sharp\+Neat.\+Genomes.\+Rbf\+Neat.\+Rbf\+Genome\+Factory}} \\*A sub-\/class of Neat\+Genome\+Factory for creating R\+B\+F-\/\+Neat genomes. R\+BF = Radial Basis Functions }{\pageref{class_sharp_neat_1_1_genomes_1_1_rbf_neat_1_1_rbf_genome_factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_relaxing_cyclic_network}{Sharp\+Neat.\+Phenomes.\+Neural\+Nets.\+Relaxing\+Cyclic\+Network}} \\*A version of \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Cyclic\+Network}} that activates a network until it becomes \textquotesingle{}relaxed\textquotesingle{} rather than for some fixed number of iterations. This class is exactly the same as \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_cyclic_network}{Cyclic\+Network}} in all other respects; See that class for more detailed info }{\pageref{class_sharp_neat_1_1_phenomes_1_1_neural_nets_1_1_relaxing_cyclic_network}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Sharp\+Neat.\+Network.\+Re\+LU}} \\*Rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_re_l_u}{Re\+LU}}) }{\pageref{class_sharp_neat_1_1_network_1_1_re_l_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_scaled_e_l_u}{Sharp\+Neat.\+Network.\+Scaled\+E\+LU}} \\*Scaled Exponential \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_linear}{Linear}} Unit (S\+E\+LU) }{\pageref{class_sharp_neat_1_1_network_1_1_scaled_e_l_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_selective_genome_list_evaluator}{Sharp\+Neat.\+Core.\+Selective\+Genome\+List\+Evaluator$<$ T\+Genome $>$}} \\*An \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}{I\+Genome\+List\+Evaluator}} that wraps another \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}{I\+Genome\+List\+Evaluator}} and filters/selects the genomes that are to be passed to the wrapped evaluator based on some predicate/test }{\pageref{class_sharp_neat_1_1_core_1_1_selective_genome_list_evaluator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_serial_genome_list_evaluator}{Sharp\+Neat.\+Core.\+Serial\+Genome\+List\+Evaluator$<$ T\+Genome, T\+Phenome $>$}} \\*A concrete implementation of \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_genome_list_evaluator}{I\+Genome\+List\+Evaluator}} that evaluates genomes independently of each other and in series on a single thread }{\pageref{class_sharp_neat_1_1_core_1_1_serial_genome_list_evaluator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_sharp_neat_exception}{Sharp\+Neat.\+Sharp\+Neat\+Exception}} \\*General purpose exception class for use within \mbox{\hyperlink{namespace_sharp_neat}{Sharp\+Neat}} }{\pageref{class_sharp_neat_1_1_sharp_neat_exception}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Sharp\+Neat.\+Phenomes.\+Signal\+Array}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Signal\+Array}} wraps a native array along with an offset into that array. The resulting \mbox{\hyperlink{class_sharp_neat_1_1_phenomes_1_1_signal_array}{Signal\+Array}} provides offset indexed access to the underlying native array }{\pageref{class_sharp_neat_1_1_phenomes_1_1_signal_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_sine}{Sharp\+Neat.\+Network.\+Sine}} \\*\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_sine}{Sine}} activation function with doubled period }{\pageref{class_sharp_neat_1_1_network_1_1_sine}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_soft_sign_steep}{Sharp\+Neat.\+Network.\+Soft\+Sign\+Steep}} \\*The softsign sigmoid. This is a variant of softsign that has a steeper slope at and around the origin that is intended to be a similar slope to that of \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_logistic_function_steep}{Logistic\+Function\+Steep}} }{\pageref{class_sharp_neat_1_1_network_1_1_soft_sign_steep}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_specie}{Sharp\+Neat.\+Core.\+Specie$<$ T\+Genome $>$}} \\*Represents a single specie within a speciated population }{\pageref{class_sharp_neat_1_1_core_1_1_specie}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_s_re_l_u}{Sharp\+Neat.\+Network.\+S\+Re\+LU}} \\*S-\/shaped rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_s_re_l_u}{S\+Re\+LU}}). From\+: \href{https://en.wikipedia.org/wiki/Activation_function}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Activation\+\_\+function}} \href{https://arxiv.org/abs/1512.07030}{\texttt{ https\+://arxiv.\+org/abs/1512.\+07030}} \mbox{[}Deep Learning with S-\/shaped Rectified \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_linear}{Linear}} Activation Units\mbox{]} }{\pageref{class_sharp_neat_1_1_network_1_1_s_re_l_u}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_s_re_l_u_shifted}{Sharp\+Neat.\+Network.\+S\+Re\+L\+U\+Shifted}} \\*S-\/shaped rectified linear activation unit (\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_s_re_l_u}{S\+Re\+LU}}). Shifted on the x-\/axis so that x=0 gives y=0.\+5, in keeping with the logistic sigmoid. From\+: \href{https://en.wikipedia.org/wiki/Activation_function}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Activation\+\_\+function}} \href{https://arxiv.org/abs/1512.07030}{\texttt{ https\+://arxiv.\+org/abs/1512.\+07030}} \mbox{[}Deep Learning with S-\/shaped Rectified \mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_linear}{Linear}} Activation Units\mbox{]} }{\pageref{class_sharp_neat_1_1_network_1_1_s_re_l_u_shifted}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Substrate}} \\*Hyper\+N\+E\+AT substrate. Encapsulates substrate nodes in sets and connections. Connections can be defined explicitly or by providing mapping functions that map (connect) between nodes in sets. Node sets can be arranged as layers, however there is no limitation on node positions within the substrate -\/ nodes in a set can be distributed throughout the substrate with no restrictions based on e.\+g. where nodes in other sets are located }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_connection}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Substrate\+Connection}} \\*Represents a connection between two nodes in a Hyper\+N\+E\+AT substrate. The node positions are represented as arrays of numbers so as not to limit the number of dimensions that positions (and therefore substrates) can be defined within }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_connection}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_node}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Substrate\+Node}} \\*Represents a node within a Hyper\+N\+E\+AT substrate }{\pageref{struct_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_node_set}{Sharp\+Neat.\+Decoders.\+Hyper\+Neat.\+Substrate\+Node\+Set}} \\*Represents a set of nodes on a substrate. Nodesets are used to represent sets such as the input and output nodes. Hidden nodes can be represented as layers with each layer being represented by a set. This allows connection mapping to be defined between sets }{\pageref{class_sharp_neat_1_1_decoders_1_1_hyper_neat_1_1_substrate_node_set}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_network_1_1_tan_h}{Sharp\+Neat.\+Network.\+TanH}} }{\pageref{class_sharp_neat_1_1_network_1_1_tan_h}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_utility_1_1_u_int32_id_generator}{Sharp\+Neat.\+Utility.\+U\+Int32\+Id\+Generator}} \\*Conveniently encapsulates a single U\+Int32, which is incremented to produce new I\+Ds }{\pageref{class_sharp_neat_1_1_utility_1_1_u_int32_id_generator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_sharp_neat_1_1_core_1_1_update_scheme}{Sharp\+Neat.\+Core.\+Update\+Scheme}} \\*Represents an update scheme for an \mbox{\hyperlink{interface_sharp_neat_1_1_core_1_1_i_evolution_algorithm}{I\+Evolution\+Algorithm}}. e.\+g. update per some time duration or some number of generations }{\pageref{class_sharp_neat_1_1_core_1_1_update_scheme}}{}
\end{DoxyCompactList}
