\hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment}{}\doxysection{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment$<$ T $>$ Class Template Reference}
\label{class_sharp_neat_1_1_black_box_1_1_vector_segment}\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}


Wraps a native array along with an offset into that array. The resulting \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} provides offset indexed access to the underlying native array.  


Inheritance diagram for Sharp\+Neat.\+Black\+Box.\+Vector\+Segment$<$ T $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sharp_neat_1_1_black_box_1_1_vector_segment}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_aa4a356f063f44ec67535a6f887ee28f5}{Vector\+Segment}} (T\mbox{[}$\,$\mbox{]} inner\+Array, int offset, int length)
\begin{DoxyCompactList}\small\item\em Construct a \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} that wraps the provided inner\+Array. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_ad50bbb7387c339b44c9a21a62b9f2814}{Copy\+To}} (T\mbox{[}$\,$\mbox{]} target\+Array, int target\+Index)
\begin{DoxyCompactList}\small\item\em Copies all elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target array starting at the specified target Array index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38534040cba68dcaba2ae44d6a47ad61}{Copy\+To}} (T\mbox{[}$\,$\mbox{]} target\+Array, int target\+Index, int length)
\begin{DoxyCompactList}\small\item\em Copies {\itshape length}  elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target array starting at the specified target Array index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a5abc8f65235202efecbf90929c2eb9f9}{Copy\+To}} (T\mbox{[}$\,$\mbox{]} target\+Array, int target\+Index, int source\+Index, int length)
\begin{DoxyCompactList}\small\item\em Copies {\itshape length}  elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target starting from {\itshape target\+Index}  on the target array and {\itshape source\+Index}  on the current source \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38f6127d510be6e0cb1f0d8e830d985d}{Copy\+From}} (T\mbox{[}$\,$\mbox{]} source\+Array, int target\+Index)
\begin{DoxyCompactList}\small\item\em Copies all elements from the source array writing them into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a220430a97a294387adf9e2ada597c30d}{Copy\+From}} (T\mbox{[}$\,$\mbox{]} source\+Array, int target\+Index, int length)
\begin{DoxyCompactList}\small\item\em Copies {\itshape length}  elements from the source array writing them to the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a37b955444aafdf1602f9b1f4a04a6f3d}{Copy\+From}} (T\mbox{[}$\,$\mbox{]} source\+Array, int source\+Index, int target\+Index, int length)
\begin{DoxyCompactList}\small\item\em Copies {\itshape length}  elements starting from source\+Index on source\+Array to the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_afff156ff34985aaf65cb5425607e7a3f}{Reset}} ()
\begin{DoxyCompactList}\small\item\em Reset all array elements to zero. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a0214a37047761895d1051323652d7380}{Length}} =$>$ \+\_\+length
\begin{DoxyCompactList}\small\item\em Gets the length of the signal array. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
T \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment_a4992c1e1abc70c0793b3e939dec34350}{this\mbox{[}int index\mbox{]}}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets or sets the single value at the specified index. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Wraps a native array along with an offset into that array. The resulting \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} provides offset indexed access to the underlying native array. 

\mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} minimizes the amount of value copying required when setting input signal values to, and reading output values from an \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_black_box}{I\+Black\+Box}}. E.\+g. Cyclic\+Neural\+Net requires all input, output and hidden node activation values to be stored in a single array. This class allows us to handle direct access to the input and output values through their own \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}}, thus we can set individual values in the underlying native array directly without having knowledge of that array\textquotesingle{}s structure. An alternative would be to pass arrays to Set\+Inputs() and Set\+Output() methods, requiring us to copy the complete contents of the arrays into the \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_black_box}{I\+Black\+Box}}\textquotesingle{}s working array on each call.

This class is effectively a substitute for array pointer manipulation as is possible in C++, e.\+g. in C++ you might do something like\+: {\ttfamily  double\mbox{[}\mbox{]} all\+Signals = new double\mbox{[}100\mbox{]}; double\mbox{[}\mbox{]} input\+Signals = \&all\+Signals; double\mbox{[}\mbox{]} output\+Signals = \&all\+Signals + 10; // Skip input neurons. } In the above example access to the real items outside of the bounds of the sub-\/ranges is possible (e.\+g. input\+Signals\mbox{[}10\mbox{]} yields the first output signal). \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} also does not check for such out-\/of-\/bounds accesses, accept when running with a debugger attached in which case assertions will make these tests.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Vector data type.\\
\hline
\end{DoxyTemplParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em struct}]\end{description}
\end{Desc}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_aa4a356f063f44ec67535a6f887ee28f5}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_aa4a356f063f44ec67535a6f887ee28f5}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!VectorSegment@{VectorSegment}}
\index{VectorSegment@{VectorSegment}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{VectorSegment()}{VectorSegment()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.\mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{inner\+Array,  }\item[{int}]{offset,  }\item[{int}]{length }\end{DoxyParamCaption})}



Construct a \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} that wraps the provided inner\+Array. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a37b955444aafdf1602f9b1f4a04a6f3d}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a37b955444aafdf1602f9b1f4a04a6f3d}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyFrom@{CopyFrom}}
\index{CopyFrom@{CopyFrom}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyFrom()}{CopyFrom()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+From (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{source\+Array,  }\item[{int}]{source\+Index,  }\item[{int}]{target\+Index,  }\item[{int}]{length }\end{DoxyParamCaption})}



Copies {\itshape length}  elements starting from source\+Index on source\+Array to the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. 


\begin{DoxyParams}{Parameters}
{\em source\+Array} & The array to copy elements from.\\
\hline
{\em source\+Index} & The source\+Array index at which copying begins.\\
\hline
{\em target\+Index} & The index into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} at which copying begins.\\
\hline
{\em length} & The number of elements to copy.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_a3b8fa706af3dc711b83e93558c1814f6}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38f6127d510be6e0cb1f0d8e830d985d}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38f6127d510be6e0cb1f0d8e830d985d}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyFrom@{CopyFrom}}
\index{CopyFrom@{CopyFrom}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyFrom()}{CopyFrom()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+From (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{source\+Array,  }\item[{int}]{target\+Index }\end{DoxyParamCaption})}



Copies all elements from the source array writing them into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. 


\begin{DoxyParams}{Parameters}
{\em source\+Array} & The array to copy elements from.\\
\hline
{\em target\+Index} & The index into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} at which copying begins.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_a2bd6d16e242dec4a07944dd6ad33049c}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a220430a97a294387adf9e2ada597c30d}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a220430a97a294387adf9e2ada597c30d}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyFrom@{CopyFrom}}
\index{CopyFrom@{CopyFrom}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyFrom()}{CopyFrom()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+From (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{source\+Array,  }\item[{int}]{target\+Index,  }\item[{int}]{length }\end{DoxyParamCaption})}



Copies {\itshape length}  elements from the source array writing them to the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} starting at the specified target\+Index. 


\begin{DoxyParams}{Parameters}
{\em source\+Array} & The array to copy elements from.\\
\hline
{\em target\+Index} & The index into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} at which copying begins.\\
\hline
{\em length} & The number of elements to copy.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_a10441003c52ba9a422db1d16045ec54d}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_ad50bbb7387c339b44c9a21a62b9f2814}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_ad50bbb7387c339b44c9a21a62b9f2814}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyTo@{CopyTo}}
\index{CopyTo@{CopyTo}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyTo()}{CopyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+To (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{target\+Array,  }\item[{int}]{target\+Index }\end{DoxyParamCaption})}



Copies all elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target array starting at the specified target Array index. 


\begin{DoxyParams}{Parameters}
{\em target\+Array} & The array to copy elements to.\\
\hline
{\em target\+Index} & The target\+Array index at which copying to begins.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_afd8297af17258613eaa17e3d2e4c6aa1}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38534040cba68dcaba2ae44d6a47ad61}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a38534040cba68dcaba2ae44d6a47ad61}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyTo@{CopyTo}}
\index{CopyTo@{CopyTo}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyTo()}{CopyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+To (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{target\+Array,  }\item[{int}]{target\+Index,  }\item[{int}]{length }\end{DoxyParamCaption})}



Copies {\itshape length}  elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target array starting at the specified target Array index. 


\begin{DoxyParams}{Parameters}
{\em target\+Array} & The array to copy elements to.\\
\hline
{\em target\+Index} & The target\+Array index at which storing begins.\\
\hline
{\em length} & The number of elements to copy.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_abaec455354d95a69c4a9e51829da3cf7}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a5abc8f65235202efecbf90929c2eb9f9}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a5abc8f65235202efecbf90929c2eb9f9}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!CopyTo@{CopyTo}}
\index{CopyTo@{CopyTo}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{CopyTo()}{CopyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Copy\+To (\begin{DoxyParamCaption}\item[{T\mbox{[}$\,$\mbox{]}}]{target\+Array,  }\item[{int}]{target\+Index,  }\item[{int}]{source\+Index,  }\item[{int}]{length }\end{DoxyParamCaption})}



Copies {\itshape length}  elements from the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} to the specified target starting from {\itshape target\+Index}  on the target array and {\itshape source\+Index}  on the current source \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}}. 


\begin{DoxyParams}{Parameters}
{\em target\+Array} & The array to copy elements to.\\
\hline
{\em target\+Index} & The target\+Array index at which copying begins.\\
\hline
{\em source\+Index} & The index into the current \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Vector\+Segment}} at which copying begins.\\
\hline
{\em length} & The number of elements to copy.\\
\hline
\end{DoxyParams}


Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_af2c66997aac8f568342486fbe5c50e59}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.

\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_afff156ff34985aaf65cb5425607e7a3f}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_afff156ff34985aaf65cb5425607e7a3f}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!Reset@{Reset}}
\index{Reset@{Reset}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Reset()}{Reset()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Reset all array elements to zero. 



Implements \mbox{\hyperlink{interface_sharp_neat_1_1_black_box_1_1_i_vector_afc16eea62b519e6f0bc1957e7570bfd1}{Sharp\+Neat.\+Black\+Box.\+I\+Vector$<$ T $>$}}.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a0214a37047761895d1051323652d7380}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a0214a37047761895d1051323652d7380}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!Length@{Length}}
\index{Length@{Length}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Length}{Length}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.Length =$>$ \+\_\+length}



Gets the length of the signal array. 



\doxysubsection{Property Documentation}
\mbox{\Hypertarget{class_sharp_neat_1_1_black_box_1_1_vector_segment_a4992c1e1abc70c0793b3e939dec34350}\label{class_sharp_neat_1_1_black_box_1_1_vector_segment_a4992c1e1abc70c0793b3e939dec34350}} 
\index{SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}!this\mbox{[}int index\mbox{]}@{this[int index]}}
\index{this\mbox{[}int index\mbox{]}@{this[int index]}!SharpNeat.BlackBox.VectorSegment$<$ T $>$@{SharpNeat.BlackBox.VectorSegment$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{this[int index]}{this[int index]}}
{\footnotesize\ttfamily T \mbox{\hyperlink{class_sharp_neat_1_1_black_box_1_1_vector_segment}{Sharp\+Neat.\+Black\+Box.\+Vector\+Segment}}$<$ T $>$.this\mbox{[}int index\mbox{]}\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Gets or sets the single value at the specified index. 

Debug asserts are used to check the index value, this avoids the check in release builds thus improving performance, but includes the check in debug builds. \mbox{\hyperlink{namespace_sharp_neat_1_1_tasks}{Tasks}} will typically access this indexer heavily, therefore the removal of the test in release builds was deemed a reasonable choice here. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Sharp\+Neat\+Lib/\+Black\+Box/Vector\+Segment.\+cs\end{DoxyCompactItemize}
